const crossEntropyLoss = {"name":"cross_entropy_loss","input":["INPUT_0","INPUT_1"],"output":["vertex_7:0"],"nodes":[{"name":"vertex_1","op":"softmax","input":["INPUT_0:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"vertex_2","op":"gather","input":["vertex_1:0","INPUT_1:0"],"literal":[]},{"name":"vertex_4","op":"log","input":["vertex_2:0"],"literal":[]},{"name":"vertex_6","op":"reduce_avg","input":["vertex_4:0"],"literal":[]},{"name":"vertex_7","op":"negate","input":["vertex_6:0"],"literal":[]}],"module_import":[],"doc":{"input":["2D Tensor, shape of (N,D)","Indices, shape (D), dtype \"int32\""],"output":["Loss (a scalar)"],"doc":"Implements the cross-entropy loss."}}
const getWeight = {"name":"get_weight","input":["INPUT_0","INPUT_1"],"output":["final:0"],"nodes":[{"name":"multiplier_params","op":"js_function","input":["INPUT_0:0"],"literal":["tensor => [[], Math.sqrt(2/tensor.shape.slice(1).reduce((a,b)=>a*b,1)), tensor.dtype]"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"weight_params","op":"js_function","input":["INPUT_0:0","INPUT_1:0"],"literal":["(tensor, units) => [[...tensor.shape.slice(1), units], \"normal\"]"]},{"name":"multiplier","op":"get_tensor","input":["multiplier_params:0","multiplier_params:1","multiplier_params:2"],"literal":[]},{"name":"unscaled_weight","op":"get_tensor","input":["weight_params:0","weight_params:1","multiplier_params:2"],"literal":[]},{"name":"scaled","op":"multiply","input":["multiplier:0","unscaled_weight:0"],"literal":[]},{"name":"final","op":"variable","input":["scaled:0","collections:0"],"literal":[]},{"name":"collections","op":"literals","input":[],"literal":[["trainable","regularization"]]}],"module_import":[],"doc":{"input":["Input tensor","Number of units"],"output":["Weight tensor"],"doc":"Gets weight tensor using he initialization"}}
const getBias = {"name":"get_bias","input":["INPUT_0"],"output":["vertex_3:0"],"nodes":[{"name":"vertex_2","op":"get_tensor","input":["INPUT_0:0","vertex_1:0","INPUT_0:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"vertex_3","op":"variable","input":["vertex_2:0","vertex_1:1"],"literal":[]},{"name":"vertex_1","op":"literals","input":[],"literal":["zeros",["trainable"]]}],"module_import":[],"doc":{"input":["Input tensor","Nuber of units"],"output":["Result (WX+b)","Weight tensor","Bias tensor"],"doc":"Implements a dense layer without activation"}}
const dense = {"name":"layer_dense","input":["INPUT_0","INPUT_1"],"output":["wx_b:0","weight:0","bias:0"],"nodes":[{"name":"matmul","op":"matmul","input":["INPUT_0:0","weight:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"weight","op":"get_weight","input":["INPUT_0:0","INPUT_1:0"],"literal":[]},{"name":"bias","op":"get_bias","input":["matmul:0"],"literal":[]},{"name":"wx_b","op":"add","input":["matmul:0","bias:0"],"literal":[]}],"module_import":["get_weight","get_bias"],"doc":{"input":["Input tensor","Nuber of units"],"output":["Result (WX+b)","Weight tensor","Bias tensor"],"doc":"Implements a dense layer without activation"}}
const get_conv_weight = {"name":"get_conv_weight","input":["INPUT_0","INPUT_1","INPUT_2"],"output":["weight_var:0"],"nodes":[{"name":"scale_calc","op":"js_function","input":["INPUT_0:0"],"literal":["(tensor) => [[], Math.sqrt(2/tensor.shape.slice(1).reduce((a,b)=>a*b,1)), tensor.dtype]"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_2","op":"placeholder","input":[],"literal":[]},{"name":"shape","op":"js_function","input":["INPUT_0:0","INPUT_1:0","INPUT_2:0"],"literal":["(tensor, filter, units) => {\nconst inDepth = tensor.shape.slice(-1)[0];\nconst newShape = [...filter, inDepth, units || inDepth];\nreturn [newShape, \"normal\", tensor.dtype];\n}"]},{"name":"vertex_2","op":"get_tensor","input":["shape:0","shape:1","shape:2"],"literal":[]},{"name":"scale_tensor","op":"get_tensor","input":["scale_calc:0","scale_calc:1","scale_calc:2"],"literal":[]},{"name":"weight_var","op":"variable","input":["scaling:0","collections:0"],"literal":[]},{"name":"scaling","op":"multiply","input":["vertex_2:0","scale_tensor:0"],"literal":[]},{"name":"collections","op":"literals","input":[],"literal":[["trainable","regularization"]]}],"module_import":["layer_dense","cross_entropy_loss"],"doc":{"input":["Input tensor","Filter shape (array of positive integers)","Out Channels"],"output":["Weight tensor"],"doc":"Gets a weight tensor (ie filter) for convolution."}}
const layer_conv = {"name":"layer_conv","input":["INPUT_0","INPUT_1","INPUT_2","INPUT_3","INPUT_4"],"output":["vertex_6:0"],"nodes":[{"name":"vertex_1","op":"js_function","input":["INPUT_0:0","INPUT_2:0"],"literal":["(input, units) => [[units], \"zeros\", input.dtype, [\"trainable\"]]"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_2","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_3","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_4","op":"placeholder","input":[],"literal":[]},{"name":"vertex_2","op":"get_conv_weight","input":["INPUT_0:0","INPUT_1:0","INPUT_2:0"],"literal":[]},{"name":"vertex_5","op":"convolution","input":["INPUT_0:0","vertex_2:0","INPUT_3:0","INPUT_4:0"],"literal":[]},{"name":"vertex_3","op":"get_tensor","input":["vertex_1:0","vertex_1:1","vertex_1:2"],"literal":[]},{"name":"bias","op":"variable","input":["vertex_3:0","vertex_1:3"],"literal":[]},{"name":"vertex_6","op":"add","input":["bias:0","vertex_5:0"],"literal":[]}],"module_import":["get_conv_weight"],"doc":{"input":["Input tensor","Filter shape (array of positive integers)","Output Channels","(optional) Strides","(optional) Padding"],"output":["Convolution"],"doc":"Implements a convolution with bias, no activation"}}

export const baseModules = [crossEntropyLoss, getWeight, getBias, dense, get_conv_weight, layer_conv]
export const defaultImports = ["layer_dense","layer_conv","cross_entropy_loss"]
