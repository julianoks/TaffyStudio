<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Deep CNN MNIST Classifier | Tutorial | TensorStudio</title>
    <script src="../deps/d3/d3.js"></script>
    <script src="../deps/dagre/dagre.min.js"></script>
    <link rel="stylesheet" href="../deps/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="style.css">
<script type="module">
import {displayInteractive} from './utils.js'

// Base modules
const getWeight = {"name":"get_weight","input":["INPUT_0","INPUT_1"],"output":["final:0"],"nodes":[{"name":"multiplier_params","op":"js_function","input":["INPUT_0:0"],"literal":["tensor => [[], Math.sqrt(2/tensor.shape.slice(1).reduce((a,b)=>a*b,1)), tensor.dtype]"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"weight_params","op":"js_function","input":["INPUT_0:0","INPUT_1:0"],"literal":["(tensor, units) => [[...tensor.shape.slice(1), units], \"normal\"]"]},{"name":"multiplier","op":"get_tensor","input":["multiplier_params:0","multiplier_params:1","multiplier_params:2"],"literal":[]},{"name":"unscaled_weight","op":"get_tensor","input":["weight_params:0","weight_params:1","multiplier_params:2"],"literal":[]},{"name":"scaled","op":"multiply","input":["multiplier:0","unscaled_weight:0"],"literal":[]},{"name":"final","op":"variable","input":["scaled:0","collections:0"],"literal":[]},{"name":"collections","op":"literals","input":[],"literal":[["trainable","regularization"]]}],"module_import":[],"doc":{"input":["Input tensor","Number of units"],"output":["Weight tensor"],"doc":"Gets weight tensor using he initialization"}}
const getBias = {"name":"get_bias","input":["INPUT_0"],"output":["vertex_3:0"],"nodes":[{"name":"vertex_2","op":"get_tensor","input":["get_shape:0","vertex_1:0","INPUT_0:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"get_shape","op":"js_function","input":["INPUT_0:0"],"literal":["t => [t.shape.slice(1)]"]},{"name":"vertex_3","op":"variable","input":["vertex_2:0","vertex_1:1"],"literal":[]},{"name":"vertex_1","op":"literals","input":[],"literal":["zeros",["trainable"]]}],"module_import":[],"doc":{"input":["Input 1"],"output":["Output 1"],"doc":"Implements module \"get_bias\""}}
const denseLayer = {"name":"denseLayer","input":["INPUT_0","INPUT_1"],"output":["XW_b:0"],"nodes":[{"name":"ingest","op":"js_function","input":["INPUT_0:0","INPUT_1:0"],"literal":["(tensor, givenUnits) => {\nif(!(tensor.shape && tensor.shape.length>=2)){\nthrow(\"First input must be tensor of rank>=2\");}\nconst units = givenUnits || tensor.shape.slice(-1)[0];\nif(!(Number.isInteger(units) && units>0)){\nthrow(\"Second input, units, must be a positive integer.\");}\nreturn [tensor, units];\n}"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"bias","op":"get_bias","input":["XW:0"],"literal":[]},{"name":"XW","op":"matmul","input":["ingest:0","weight:0"],"literal":[]},{"name":"XW_b","op":"add","input":["XW:0","bias:0"],"literal":[]},{"name":"weight","op":"get_weight","input":["ingest:0","ingest:1"],"literal":[]}],"module_import":["get_weight","get_bias"],"doc":{"input":["Input 1","Input 2"],"output":["Output 1"],"doc":"Implements module \"denseLayer\""}};

const get_conv_weight = {"name":"get_conv_weight","input":["INPUT_0","INPUT_1","INPUT_2"],"output":["weight_var:0"],"nodes":[{"name":"scale_calc","op":"js_function","input":["INPUT_0:0"],"literal":["(tensor) => [[], Math.sqrt(2/tensor.shape.slice(1).reduce((a,b)=>a*b,1)), tensor.dtype]"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_2","op":"placeholder","input":[],"literal":[]},{"name":"shape","op":"js_function","input":["INPUT_0:0","INPUT_1:0","INPUT_2:0"],"literal":["(tensor, filter, units) => {\nconst inDepth = tensor.shape.slice(-1)[0];\nconst newShape = [...filter, inDepth, units || inDepth];\nreturn [newShape, \"normal\", tensor.dtype];\n}"]},{"name":"vertex_2","op":"get_tensor","input":["shape:0","shape:1","shape:2"],"literal":[]},{"name":"scale_tensor","op":"get_tensor","input":["scale_calc:0","scale_calc:1","scale_calc:2"],"literal":[]},{"name":"weight_var","op":"variable","input":["scaling:0","collections:0"],"literal":[]},{"name":"scaling","op":"multiply","input":["vertex_2:0","scale_tensor:0"],"literal":[]},{"name":"collections","op":"literals","input":[],"literal":[["trainable","regularization"]]}],"module_import":[],"doc":{"input":["Input tensor","Filter shape (array of positive integers)","Out Channels"],"output":["Weight tensor"],"doc":"Gets a weight tensor (ie filter) for convolution."}}
const convLayer = {"name":"convLayer","input":["INPUT_0","INPUT_1","INPUT_2","INPUT_3","INPUT_4"],"output":["vertex_6:0"],"nodes":[{"name":"ingest","op":"js_function","input":["INPUT_0:0","INPUT_1:0","INPUT_2:0","INPUT_3:0","INPUT_4:0"],"literal":["(...args) => {\nconst [tensor, filter, channels] = args;\nif(!(tensor.shape && tensor.shape.length >= 3)){throw(\"First input, tensor, must be tensor of rank>=3\");}\nif(!Array.isArray(filter)){throw(\"Second input, filter, must be an array of positive integers\");}\nif(!Number.isInteger(channels)){throw(\"Third input, channels, must be an integer.\");}\nreturn args;\n}"]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_2","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_3","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_4","op":"placeholder","input":[],"literal":[]},{"name":"vertex_3","op":"get_tensor","input":["vertex_1:0","vertex_1:1","vertex_1:2"],"literal":[]},{"name":"vertex_1","op":"js_function","input":["ingest:0","ingest:2"],"literal":["(input, units) => [[units], \"zeros\", input.dtype, [\"trainable\"]]"]},{"name":"bias","op":"variable","input":["vertex_3:0","vertex_1:3"],"literal":[]},{"name":"vertex_10","op":"convolution","input":["ingest:0","vertex_2:0","ingest:3","ingest:4"],"literal":[]},{"name":"vertex_2","op":"get_conv_weight","input":["ingest:0","ingest:1","ingest:2"],"literal":[]},{"name":"vertex_6","op":"add","input":["bias:0","vertex_10:0"],"literal":[]}],"module_import":["get_conv_weight"],"doc":{"input":["Input tensor","Filter shape (array of positive integers)","Output Channels","(optional) Strides","(optional) Padding"],"output":["Convolution"],"doc":"Implements a convolution with bias, no activation"}}
const convReluLayer = {"name":"convReluLayer","input":["INPUT_0","INPUT_1","INPUT_2","INPUT_3","INPUT_4"],"output":["ReLU:0"],"nodes":[{"name":"conv","op":"convLayer","input":["INPUT_0:0","INPUT_1:0","INPUT_2:0","INPUT_3:0","INPUT_4:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_2","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_3","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_4","op":"placeholder","input":[],"literal":[]},{"name":"ReLU","op":"relu","input":["conv:0"],"literal":[]}],"module_import":["convLayer"],"doc":{"input":["Input tensor","Filter shape (array of positive integers)","Output Channels","(optional) Strides","(optional) Padding"],"output":["Convolution with ReLU applied"],"doc":"Implements a convolution with bias, followed by a ReLU activation"}}

const model = {"name":"model","input":["INPUT_0"],"output":["logits:0"],"nodes":[{"name":"reshapeInput","op":"reshape","input":["INPUT_0:0","newShape:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"newShape","op":"literals","input":[],"literal":[["batch",28,28,1]]},{"name":"conv1","op":"convReluLayer","input":["reshapeInput:0","convParams1:0","convParams1:1"],"literal":[]},{"name":"convParams1","op":"literals","input":[],"literal":[[3,3],6,2]},{"name":"conv2","op":"convReluLayer","input":["conv1:0","convParams2:0","convParams2:1","convParams2:2"],"literal":[]},{"name":"convParams2","op":"literals","input":[],"literal":[[2,2],6,2]},{"name":"conv3","op":"convReluLayer","input":["normConv2:0","convParams3:0","convParams3:1","convParams3:2"],"literal":[]},{"name":"convParams3","op":"literals","input":[],"literal":[[2,2],16,3]},{"name":"conv4","op":"convReluLayer","input":["conv3:0","convParams4:0","convParams4:1"],"literal":[]},{"name":"convParams4","op":"literals","input":[],"literal":[[1,1],8]},{"name":"logits","op":"denseLayer","input":["flatten:0","nClasses:0"],"literal":[]},{"name":"normConv2","op":"batch_norm","input":["conv2:0"],"literal":[]},{"name":"normBeforeDense","op":"batch_norm","input":["conv4:0"],"literal":[]},{"name":"flatten","op":"reshape","input":["normBeforeDense:0","flatShape:0"],"literal":[]},{"name":"flatShape","op":"literals","input":[],"literal":[["batch",200]]},{"name":"nClasses","op":"literals","input":[],"literal":[10]}],"module_import":["convReluLayer","denseLayer"],"doc":{"input":["A batch of MNIST images, of the shape (batch, 784)"],"output":["Logits on the MNIST images, of the shape (batch, 10)"],"doc":"A MNIST classifier implementing a deep CNN that uses batch normalization"}}

const modelModules = [getWeight, getBias, denseLayer, get_conv_weight, convLayer, convReluLayer, model]

const crossEntropyLoss = {"name":"cross_entropy_loss","input":["INPUT_0","INPUT_1"],"output":["vertex_7:0"],"nodes":[{"name":"vertex_1","op":"softmax","input":["INPUT_0:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"vertex_2","op":"gather","input":["vertex_1:0","INPUT_1:0"],"literal":[]},{"name":"vertex_4","op":"log","input":["vertex_2:0"],"literal":[]},{"name":"vertex_6","op":"reduce_avg","input":["vertex_4:0"],"literal":[]},{"name":"vertex_7","op":"negate","input":["vertex_6:0"],"literal":[]}],"module_import":[],"doc":{"input":["2D Tensor, shape of (N,D)","Indices, shape (D), dtype \"int32\""],"output":["Loss (a scalar)"],"doc":"Implements the cross-entropy loss."}}
const sum_squares = {"name":"sum_squares","input":["INPUT_0"],"output":["vertex_6:0"],"nodes":[{"name":"vertex_2","op":"pow","input":["INPUT_0:0","vertex_5:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"vertex_6","op":"reduce_sum","input":["vertex_2:0"],"literal":[]},{"name":"vertex_5","op":"get_tensor","input":["vertex_4:0","vertex_4:1"],"literal":[]},{"name":"vertex_4","op":"literals","input":[],"literal":[[],2]}],"module_import":[],"doc":{"input":["Input 1"],"output":["Output 1"],"doc":"Implements module \"sum_squares\""}}
const L2_regularization = {"name":"L2_regularization","input":["INPUT_0","INPUT_1"],"output":["vertex_6:0"],"nodes":[{"name":"vertex_2","op":"get_collection","input":["vertex_3:0","INPUT_0:0"],"literal":[]},{"name":"INPUT_0","op":"placeholder","input":[],"literal":[]},{"name":"INPUT_1","op":"placeholder","input":[],"literal":[]},{"name":"vertex_7","op":"js_function","input":["INPUT_1:0"],"literal":["(number=1) => number"]},{"name":"vertex_1","op":"map","input":["vertex_2:0"],"literal":["sum_squares"]},{"name":"vertex_6","op":"multiply","input":["sum_l2s:0","vertex_5:0"],"literal":[]},{"name":"sum_l2s","op":"apply","input":["vertex_1:0"],"literal":["add"]},{"name":"vertex_3","op":"literals","input":[],"literal":[["regularization"]]},{"name":"vertex_5","op":"scalar","input":["vertex_7:0"],"literal":[]}],"module_import":["sum_squares"],"doc":{"input":["Control edge","Regularization strength"],"output":["Regularization loss"],"doc":"Implements L2 regularization"}}

const lossModules = [crossEntropyLoss, sum_squares, L2_regularization]

// interactives
const holder = '#interactive'

const modelNodes = ["newShape", "reshapeInput", "convParams1", "conv1", "convParams2", "conv2", "normConv2", "convParams3", "conv3", "convParams4", "conv4", "normBeforeDense", "flatShape", "flatten", "nClasses", "logits"]
window.displayModel = (showN=modelNodes.length) => {
    const showOnly = modelNodes.slice(0, showN)
    const inpDesc = {
        "INPUT_0":{"selectedType":"tensor","shape":["batch",784],"dtype":"float32","JSONtext":""},
    }
    displayInteractive(holder, "model", showOnly, modelModules, inpDesc)
}

displayModel(0)
</script>
</head>
<body>
<div class='main'>
<h2>Deep CNN MNIST Classifier</h2>
<p>
<h5>Inputs <a href="#interactive" onclick="displayModel(0)">GO!</a></h5>
We're going to solve the same MNIST problem from the previous tutorial.
Because the loss is the same as the previous tutorial, this tutorial will only focus on the model.
Our model is supposed to take a batch of images and produce a batch of logits.
Thus our module will only contain one input, of shape (batch, 784).
</p>

<h5>Reshaping the Input <a href="#interactive" onclick="displayModel(2)">GO!</a></h5>
<p>
Before applying convolution, we will reshape our images from vectors of shape (784) to a more natural image shape of (28,28,1).
Our input now has width and height 28, and a depth of a single channels (which represents darkness).
</p>

<h5>Convolutions <a href="#interactive" onclick="displayModel(6)">GO!</a></h5>
<p></p>

<h5>Batch Normalization <a href="#interactive" onclick="displayModel(7)">GO!</a></h5>
<p></p>

<h5>Convolutions, again <a href="#interactive" onclick="displayModel(11)">GO!</a></h5>
<p></p>

<h5>Batch Normalization, again <a href="#interactive" onclick="displayModel(12)">GO!</a></h5>
<p></p>

<h5>Flattening <a href="#interactive" onclick="displayModel(14)">GO!</a></h5>
<p></p>

<h5>Logits <a href="#interactive" onclick="displayModel(16)">GO!</a></h5>
<p></p>

</div>
<div class="alert alert-danger" role="alert" style="width:50%;margin-left:auto;margin-right: auto;">
My automatic graph layout doesn't yet rescale the canvas. 
<br>
Please do this manually. Sorry!
</div>
<div id='interactive'></div>

<hr>
<div class='main'>
</div>

</body>
</html>
